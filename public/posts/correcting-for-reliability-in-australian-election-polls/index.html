<!DOCTYPE html>
<html lang="en-us"><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    

<link href='//fonts.googleapis.com/css?family=PT+Sans+Narrow:400,700%7CPT+Serif:400,700,400italic' rel='stylesheet' type='text/css'>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
<script>
  MathJax = {
    tex: {
      displayMath: [['\\[', '\\]'], ['$$', '$$']],  
      inlineMath: [['\\(', '\\)']]                  
    }
  };
</script>
    










  



<link rel="stylesheet" href="http://localhost:1313/scss/main.css" />


    

    

    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
<script>
  MathJax = {
    tex: {
      displayMath: [['\\[', '\\]'], ['$$', '$$']],  
      inlineMath: [['\\(', '\\)']]                  
    }
  };
</script>

  </head><body>
    <header class="container">
    <nav class="main-nav" id="js-navbar">
      <a class="logo" href="http://localhost:1313/">Clinton Boys</a>
      <ul class="menu" id="js-menu">
        
        
        
          <li class="menu-item">
            <a href="/about/" class="menu-link">About</a>
          </li>
        
        
        
          <li class="menu-item">
            <a href="/now/" class="menu-link">Now</a>
          </li>
        
        
        
          <li class="menu-item">
            <a href="/posts/" class="menu-link">Writing</a>
          </li>
        
        
        
          <li class="menu-item">
            <a href="/projects/" class="menu-link">Projects</a>
          </li>
        
        
        
          <li class="menu-item">
            <a href="http://mtsolitary.com" class="menu-link">Notes</a>
          </li>
        
        
        <li class="menu-item--align">
          <div class="switch">
            <input class="switch-input" type="checkbox" id="themeSwitch">
            <label aria-hidden="true" class="switch-label" for="themeSwitch">On</label>
            <div aria-hidden="true" class="switch-marker"></div>
          </div>
        </li>
      </ul>
      <span class="nav-toggle" id="js-navbar-toggle">
        <svg xmlns="http://www.w3.org/2000/svg" id="Outline" viewBox="0 0 24 24" width="30" height="30" fill="var(--color-contrast-high)"><rect y="11" width="24" height="2" rx="1"/><rect y="4" width="24" height="2" rx="1"/><rect y="18" width="24" height="2" rx="1"/></svg>
      </span>
    </nav>
  </header>
<main class="section">
<div class="single-container-post">
  

  <div class="single-post-contents">
    <div class="single-feature-img">




  

</div>
    <article class="markdown">
        <h1 id="correcting-for-reliability-in-australian-election-polls"></h>Correcting for reliability in Australian election polls<a href="#correcting-for-reliability-in-australian-election-polls">
    
  </a>
</h1><p><em>January 25, 2015</em></p>
<p>In a [post]({{ site.baseurl }}{% link _posts/2014-10-06-aus-election-model.md %}) last year, I discussed the difficulties in building a model for predicting Australian elections. In the next series of posts, I want to build a few basic pieces of this model.</p>
<p>The first piece of the model I want to build is a series of reliability weights for pollsters. First let&rsquo;s have a look at who the main pollsters are in Australian elections.</p>
<p><strong>Newspoll</strong> - The best-known and most influential pollster. Polls Federal and State elections since 1985, using random telephone number selection. Only calls landlines.</p>
<p><strong>Morgan</strong> - The oldest pollster. Has polled Federal elections since the 1940s, and also polls State elections. Traditionally a door-to-door pollster, in recent years has updated its model to include SMS and internet sampling.</p>
<p><strong>Galaxy</strong> - Fairly recent pollster, polling Federal elections since 2004, and some recent state elections. Uses random telephone number selection and includes mobile phones.</p>
<p><strong>Nielsen / Ipsos</strong> Nielsen used to conduct polls for Fairfax newspapers but stopped in 2014. It has been replaced by Ipsos. Telephone pollster that calls landlines and mobiles (Nielsen used to only call landlines).</p>
<p><strong>ReachTEL</strong> - Automated dialling pollster. Polls both Federal and State elections.</p>
<p><strong>Essential</strong> - The pollster used by Crikey. Polls using email. Only polls Federal elections.</p>
<p>There are other minor pollsters floating around but we won&rsquo;t have enough data on them to create a weighting. We&rsquo;ll have to come up with a rule to assign polls not on this list a weight in the model.</p>
<p>Let&rsquo;s look at elections in Australia in the last ten years. There have been eighteen elections for either the Federal government or the state governments in NSW, QLD, VIC, SA and WA since then (we exclude the territories, and TAS because its system is completely different to the others).</p>
<p>I want to calculate accuracy for the firms above for whenever polled these elections; we will just use the final poll they released before election day. We&rsquo;ll use primary and TPP (two-party-preferred) data for our calculations. Some pollsters won&rsquo;t have all eighteen data points because they only poll federal elections.</p>
<p>Collecting the state polling data took a really long time. Federal data has been collected and curated by Phantom Trend and is available in a Github repo. There&rsquo;s no such luck for state data though, so I had to get it all myself.</p>
<p>Newspoll data is all available on their website in a fairly accessible form. Morgan data is also available but hidden in single media releases for each poll so it&rsquo;s a bit of a pain. The other pollsters are much more opaque with their data. Galaxy was helpful and actually responded to an email request with a whole bunch of data.</p>
<p>I&rsquo;m keeping all the code for my model on a Github repository <a href="https://github.com/clintonboys/emma-chisit" target="_blank" rel="noopener">here</a>. I&rsquo;ve called the model <a href="https://en.m.wiktionary.org/wiki/Emma_Chisit" target="_blank" rel="noopener"><em>Emma Chisit</em></a>.</p>
<p>After spending countless hours scraping polls, I was ready to build the poll weight calculator. Because I&rsquo;m on a bit of an object-oriented binge at the moment, I decided to do it this way. First we create a poll class, and then a special inheritance for elections.</p>
<pre><code>import pandas as pd
import numpy as np
from collections import OrderedDict

parties = {'ALP', 'LIB', 'NAT', 'COA', 'DEM', 'GRN', 'ONP', 'PUP', 'KAP', 'FF', 'CD', 'OTH'}
states = {'AUS', 'NSW', 'VIC', 'SA', 'WA', 'QLD', 'TAS'}

class Poll(object):

    def __init__(self, pollster, state, mediandate, samplesize, results, TPP):
        self._pollster = pollster
        self._state = state
        self._mediandate = mediandate
        self._samplesize = samplesize
        self._results = results
        self._tpp = TPP
        self.distance = 100000  # This variable will be used to find   closest polls to elections

    @property
    def pollster(self):
        return self._pollster

    def state(self):
        return self._state

    def median_date(self):
        return self._mediandate

    def sample_size(self):
        return self._samplesize

    def results(self,party):
        try:
            return self._results[party]
        except KeyError:
            return 0

    def change_result(self,party,new):
        try:
            self._results[party] = new
        except KeyError:
            pass

    def tpp(self):
        return self._tpp


class Election(Poll):

    ## elections are just polls with a huge sample size

    def formal_votes(self):
        return self._samplesize

    def election_date(self):
        return self._mediandate
</code></pre>
<p>Now we import all the data and initialise polls and elections for all the entries.</p>
<pre><code>def LoadPolls(state):
    poll_list = []
    filename = 'polling_data/' + state + '_state_polls.csv'
    pollframe = pd.read_csv(filename)
    for i in range(0,len(pollframe)):
        results_dict = {}
        for party in parties:
            try: 
                results_dict[party] = pollframe[party][i]
            except KeyError:
                pass
        try:
            poll_list.append(Poll(pollframe['Pollster'][i], state, pd.to_datetime(pollframe['PollMedianDate'][i]), pollframe['N'][i], results_dict, pollframe['ALP_TPP'][i]))
        except KeyError:
            poll_list.append(Poll(pollframe['Pollster'][i], state, pd.to_datetime(pollframe['PollMedianDate'][i]), pollframe['N'][i], results_dict, np.nan))
    return poll_list

def LoadElections():
    electionframe = pd.read_csv('elections_from_2000.csv')
    election_list = []
    for i in range(0,len(electionframe)):
        results_dict = {}
        for party in parties:
            try:
                results_dict[party] = electionframe[party][i]
            except KeyError:
                pass
        election_list.append(Election('Election', electionframe['State'][i], pd.to_datetime(electionframe['Date'][i]), electionframe['N'][i], results_dict, electionframe['ALP_TPP'][i]))
    return election_list
</code></pre>
<p>Once we&rsquo;ve done this the code for computing weights is pretty simple. The only clever thing we need (and that the object-oriented approach really helps with) is working out which polls are the closest to the respective elections for their pollsters. I&rsquo;m using a fifteen day cutoff. The code could definitely do with some optimisation, although the largest amount of polls I&rsquo;m ever going to be working with is a few thousand, so there&rsquo;s not much need to make it faster.</p>
<pre><code>error_dict = {}

for pollster in pollsters:
    error_dict[pollster] = []
    for election in elections_from_2000:
        potential_list = []
        for state in state_polls:
            for poll in state:
                if poll.state() == election.state():
                    if poll.pollster == pollster:
                        if 0 &lt; -(poll.median_date() - election.election_date()).days &lt; 15:
                            potential_list.append(poll)
                            poll.distance = -(poll.median_date() - election.election_date()).days
        try:
            min_dist = min(potential_list, key=attrgetter('distance'))
            error_dict[pollster].append([min_dist,election])
        except ValueError:
            pass
</code></pre>
<p>We need some helper functions to put everything together; since different pollsters poll different groups of &ldquo;others&rdquo;, and some include the Nationals and some don&rsquo;t, we need to make everything consistent.</p>
<pre><code>def JoinCoalition(poll):

    if np.isnan(poll.results('NAT')):
        poll.change_result('NAT', 0)
    if np.isnan(poll.results('COA')):
        poll.change_result('COA', poll.results('LIB') + poll.results('NAT'))

def JoinOthers(poll):

    others_vote = 0
    for party in others:
        if not np.isnan(poll.results(party)) and poll.results(party) != 0:
            others_vote = others_vote + poll.results(party)
    poll.change_result('OTH', others_vote)
</code></pre>
<p>Now we compute root-mean-squared deviation error for all the polls and average everything up.</p>
<pre><code>def ComputeRMSQ(poll, election):

    to_sum = []
    count = 0
    for party in joined_parties:
        resid = poll.results(party) - election.results(party)
        try:
            to_sum.append(math.pow(resid,2))
        except TypeError:
            pass
        count = count + 1
    tppresid = poll.tpp() - election.tpp()
    if not np.isnan(tppresid):
        try:
            to_sum.append(4*(math.pow(tppresid,2)))
        except TypeError:
            pass
    count = count + 4

    return math.sqrt(sum(to_sum)/count)

av_error = []

for pollster in pollsters:

    errors = []

    for i in range(0,len(error_dict[pollster])):

        JoinCoalition(error_dict[pollster][i][0])
        JoinCoalition(error_dict[pollster][i][1])
        JoinOthers(error_dict[pollster][i][0])
        JoinOthers(error_dict[pollster][i][1])

        errors.append(ComputeRMSQ(error_dict[pollster][i][0], error_dict[pollster][i][1]))

    av_error.append(np.mean(errors))

print np.mean(av_error)
</code></pre>
<p>This gives us the following average pollster errors, and total average error:</p>
<pre><code>Morgan    1.795
Newspoll  2.768
Galaxy    1.937
Essential 1.891
ReachTEL  3.249
2.328
[Finished in 0.8s]
</code></pre>
<p>From this we can compute the following weights to use in our model:</p>
<pre><code>Morgan    1.297
Essential 1.232
Galaxy    1.202
Newspoll  0.841
ReachTEL  0.716
[Finished in 0.7s]
</code></pre>

    </article>
    <aside>
      <div class="single-terms">
        
      </div>
      
        

        
  <section>
    <h2>Read Next</h2>
    <div class="single-next-previous">
      
        <a class="previous" href="http://localhost:1313/posts/difficulties-in-forecasting-elections-in-australia/">&laquo; Difficulties in forecasting elections in Australia</a>
      
      
        <a class="next" href="http://localhost:1313/posts/clustering-australian-electorates-by-demographic-variables/">Clustering Australian electorates by demographic variables &raquo;</a>
      
    </div>
  </section>

      
    </aside>
  </div>  <div class="footer">
    <p class="footer-copyright"><i>&copy; 2014 - 2024
      Clinton Boys. Built by hand, without the use of generative AI.</i>
      
    </p>
  </div>
</div>

    </main>
  
  








  

<script src="http://localhost:1313/main.js"></script>


</body>
</html>
